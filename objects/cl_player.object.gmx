<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sp_playerM</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1</depth>
  <persistent>0</persistent>
  <parentName>cl_moves</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///init vars
event_inherited()
jumpspeed=1.6
dir=1
former_init()
//var to set the room I came from to use in rooms with mutiple doors
origin=noone 

//keeping momentum when changing rooms from on the air
if !landed 
{
    vsp = global.exitvsp
}

warping=false

sprite_index=spPlayer0

interactiveCollisionInit()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if instance_number(cl_player)&gt;1 &amp;&amp; origin != global.lastroom {instance_destroy()}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///player controls

event_inherited()

//locking controllers out of custcenes and pause
if !global.cutscene
and !global.paused 
and !warping
{
    //Get the player's input
    key_right = keyboard_check(vk_right);
    key_left = -keyboard_check(vk_left);
    key_jump = keyboard_check(vk_space);
    //React to inputs
    dir = key_left + key_right;
}

if global.debugger {
    if keyboard_check_pressed(ord("Q")) {
    form++
    form_change(form)
    }
}

hsp = dir * movespeed;
 
if landed
{
    vsp = key_jump * -jumpspeed
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///changing the player sprites
/*
who_am_i()
*/
//forming
if lastForm != form {
    switch (form) {
        default:
        case 0:
        sprite_index = spPlayer0
        break
        case 1:
        sprite_index = spPlayer1
        break
        case 2:
        sprite_index = spPlayer2
        break
        case 3:
        sprite_index = spPlayer3
        break
        case 4:
        sprite_index = spPlayer4
        break
        case 5:
        sprite_index = spPlayer5
        break
        case 6:
        sprite_index = spPlayer6
        break
    }
}

if form&gt;6 {
    form=0
}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///player animations
/*
//falling and going up
if !landed
{
    if y&lt;yprevious {image_index=1};
    else if y=yprevious &amp;&amp; round(vsp)=0 {image_index=0};    
    else if y&gt;yprevious &amp;&amp; !place_meeting(x,y+(3*vsp),cl_wall)  {image_index=2};
} else {image_index=0}


//key respnsive up and down animations
if !global.paused
{
    if keyboard_check(vk_up)
        {sprite_index=sprite_up}
    if keyboard_check(vk_down)
        {sprite_index=sprite_down}
    if keyboard_check(vk_up) &amp;&amp; keyboard_check(vk_down) || !keyboard_check(vk_up) &amp;&amp; !keyboard_check(vk_down)
        {sprite_index=sprite_def}
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///interactive collisions

var width = sprite_width,
    height = sprite_height,
    range = interactiveColRange,
/*
Because gamemaker, nothing is really what it is so while setting the vars some of the 
code got confusing because everything is offseted by a pixel so, down there, there where
a lot o number and I coudn't tell what they were.

I just made some vars to be clear of what the bloddy fuck is going on there 
may be many more lines of code but clarity is so much fucking better
*/
    offset = 1,
    trueX1 = x - offset,
    trueY1 = y - offset,
    trueX2 = x + width - offset,
    trueY2 = y - height - offset,
//offset due to faulty collision code. fix and remove later
    horOffset = 0.4
    ;

//vertical
vX1 = trueX1
vY1 = trueY1 + range
vX2 = trueX2
vY2 = trueY2 - range

//horizontal
hX1 = trueX1 - (range + horOffset)
hY1 = trueY1
hX2 = trueX2 + (range + horOffset)
hY2 = trueY2

if collisionActive {
    
    var ver = collision_rectangle(vX1,vY1,vX2,vY2,c_interactive,false,true)
    if ver != noone {
        interactiveCollision(ver)
    }
    
    var hor = collision_rectangle(hX1,hY1,hX2,hY2,c_interactive,false,true)
    if hor != noone {
        interactiveCollision(hor)
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///debug graphis
event_inherited()
draw_self()

if global.debugger {
    var oldcolor = draw_get_color()
    
    draw_set_color(c_red)
    draw_rectangle(vX1,vY1,vX2,vY2,true)
    draw_rectangle(hX1,hY1,hX2,hY2,true)
    draw_sprite(sp_debug,0,x,y)
    
    draw_set_color(oldcolor)
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
